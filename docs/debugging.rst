Debugging FAQ
=============

This article is an attempt to codify some strategies which will allow
the build or DevOps engineer to ensure that dependencies are resolved
successfully and quickly using Degasolv.

It is organized like a FAQ. A problem is listed, together with suggested
solutions. It is hoped that these suggestions will enable the engineer to
fix the build or deploy.

``resolve-locations`` Is Taking Too Long
----------------------------------------

This is a real, real concern. By default degasolv only allows one version of each
package to land in the final resolution list. This means that degasolv is solving
an NP complete problem. That means that if degasolv is given sufficiently complicated
data, it can take upwards of an hour (sometimes waaaay past an hour) to complete
resolution. This is obviously unacceptable. What can be done? The following are
some suggestions by the author(s) of Degasolv.

Prune The Repository
++++++++++++++++++++

Usually, a typical NAS or Artifactory may have lots of old builds on
it. For example, suppose a particular build creates a debian
package. This build runs every time a commit is made to its
repository's ``develop`` branch. Therefore, a debian package for each
commit on the develop branch may land on the NAS, together with its
degasolv ``dscard`` file.

If Degasolv should not consider an artifact as an option during
resolution, it is best practice to remove it from degasolv's
repository by removing the ``dscard`` file from the NAS, then
re-running ``generate-repo-index``. Pruning (deleting) ``dscard``
files from the NAS which represent old, useless build artifacts
informs Degasolv that these old builds are not eligible for
resolution; Degasolv should not consider them as options when
resolving dependencies. For example, old builds from the develop
branch might not be desirable in the resolution process.

This is the most effective way to make sure that if there is no
correct way to resolve dependencies, Degasolv will fail fast instead
of hanging the build. It is also the least painless to implement
because no process changes or changes to Degasolv's behavior are
required.

Temporarily Use ``--resolve-strat "fast"`` and ``--disable-alternatives``
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Sometimes, Degasolv may get "snagged". This is when it is searching
for a particular dependency deep in the resolution tree, but it is not
there. This situation may cause degasolv to frantically search for a
way out by trying other alternatives highter up in the dependency
tree, thus hanging the resolution process.

If the ``--resolve-strat`` flag is set to ``"fast"`` and the
``--disable-alternatives`` flag is used, degasolv will not try to
search for another way; it will simply fail and print out what went
wrong. This is not usually desirable under normal running, but can be
very useful when debugging allowing the operator of degasolv to find
packages which are missing from the repository. Once these packages
are re-introduced, degasolv may be able to resolve things properly
again.

Keep Requirement Strings Simple
+++++++++++++++++++++++++++++++

Change Degasolv's Behavior Site-Wide
++++++++++++++++++++++++++++++++++++

It is possible to change degasolv's behavior so that package
resolution is no longer NP-complete. By doing so, the user can ensure
that package resolution is done relatively quickly every time. This
guarantee of performance always comes at a cost. Different alternatives
offer different costs. Here are some options:

- **Set ``--conflic-strat`` to ``"inclusive"``, ``--resolve-strat`` to
  ``"fast"`` and setting ``--disable-alternatives``**: this
  combination of options informs degasolv that multiple versions of
  the same package are allowed in resolution. This causes degasolv to
  behave in a similar way to the ruby package manager gem and the
  nodejs package manager npm. This ensures performance, but sacrifices
  safety.

  For example, say that there are in a software product three
  packages: ``a``, ``b``, and ``c``. Say that ``a`` passes data to a
  particular ``c`` for processing, say version ``1``, and gets back a
  result. Say again that ``b`` passes data to ``c`` at a different
  version, say version ``2`` of the ``c`` package, and gets back a
  result. Now say that package ``a`` passes data to package ``b``
  containing the results it got from its version of ``c``. ``b``
  passes these results to its version of ``c`` for interpretation, but
  ``c`` at version 2 cannot consume data generated by ``c`` at version
  ``1``, so the operation fails.

  This is why it may be important only to have one version of each
  package found in any resolution.

  If this is not a problem, then setting this option site-wide may
  be a viable solution to builds which take too long.

  Another interesting side effect of this set of site-wide options is
  that package lists created during resolution tend to get very
  lengthy. Multiple versions of packages, including the dependencies
  of those packages, are listed, causing an explosion of packages
  needed in any given resolution.

- **Set ``--conflic-strat`` to ``"prioritized"``, ``--resolve-strat`` to
  ``"fast"`` and setting ``--disable-alternatives``**: this
  combination of options informs degasolv that, given two versions of the
  same package, the later version will always be backwards-compatible
  with the older version. Under this set of options, degasolv may
  substitute any version for any other version at its discretion. This
  causes degasolv to behave in a similar way to the java package
  managers maven or ivy.  This ensures performance, but (obviously)
  sacrifices safety.

- **Set ``--disable-alternatives`` and ``--resolve-strat`` to ``"fast"``**:
  This is the safest of the option combinations, but sacrifices
  utility. Effectively, if Degasolv ever encounters a dependency
  conflict, resolution will fail and an error message will be
  printed. It will be up to the user to list more explicitly defined
  dependencies, such as listing a particular dependency at a
  particular version. It will also be necessary often to list
  dependencies of dependencies as dependencies at particular versions.
  In short, degasolv will be less useful as a dependency resolver, but
  safety will not be sacrificed.
